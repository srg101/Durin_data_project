---
title: "DURIN 2024 Thermal Tolerance"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Import Data

```{r}
library(tidylog)
library(tidyverse)
library(readxl)
library(stringr) 
library(plyr)
DURIN_data <- read_excel(path = "C:/Users/sge010/OneDrive - University of Bergen/Documents/DURIN/Durin_data_project/data/raw_data/2024 DURIN Plant Functional Traits.xlsx",
                         sheet = "Data", col_names = TRUE, trim_ws = TRUE)

# Note for now, some issues with column types reading in.
# For example, the collection time with "10:59" format doesn't read in correctly, nor does the date format for Treatment Date.



# Also, some column names aren't 'readable', i.e. Fv/Fm with '/', or height(s)
DURIN_data <- rename(DURIN_data, c("height(s)"="heights",
                     "Fv/Fm_Initial"="FvFm_Initial",
                     "Fv/Fm_PostStress"="FvFm_PostStress",
                     "Fv/Fm_Hr"="FvFm_Hr",
                     "Fv/Fm_Final"="FvFm_Final",
                     "DroughNet_plotID" = "DroughtNet_plotID"))

# Senja is spelt wrongly as Senje in DropDowns
DURIN_data$siteID<- revalue(DURIN_data$siteID, c("Senje" = "Senja"))

# Create concantenated ID code for the plants
DURIN_data$PlantSampleID = paste(DURIN_data$siteID, DURIN_data$habitat,
                                   DURIN_data$species, DURIN_data$plant_nr,
                                   sep = "_")
DURIN_data$PlantSampleID2 = paste(DURIN_data$siteID, DURIN_data$habitat,
                                   DURIN_data$species, DURIN_data$plant_nr,
                                   sep = "_")

```

## General Custom Cleaning/Issue Identifying Codes

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
# Useful custom functions ----
## Look up an individual envelope ID number to see its info ----
# Modify the select() to change which data are displayed
check <- function(barcode) {
  data <- DURIN_data |>
    select(envelope_ID, day, month, year, siteID, habitat, species, proj_2024,
           project,
           ageClass, DroughtTrt, DroughtNet_plotID,
           plant_nr, leaf_nr, leaf_age, sample,
           CollTime, PairedWith, calluna_shoot_type, bulk_nr_leaves,
           TempExp, TempExpTime, TempExpTimeUnit, FvFm_Initial, FvFm_PostStress, FvFm_Hr, FvFm_Final, 
           wet_mass_g,
           leaf_thickness_1_mm, leaf_thickness_2_mm, leaf_thickness_3_mm,
           dry_mass_g, scanned,
           nearest_DURIN_plotID, sampleType, heights,
           TreatmentDate, TreatmentTime,
           remark, remarks_2, flag,
           # New Column, not on sheet but helpful
           PlantSampleID
           ) |>
    filter(envelope_ID == barcode)
  data
}
```

## Data Checking

```{r}
## Find duplicate barcodes ----
error.duplicates <- DURIN_data |>
  # We don't care about exact duplicates so distinct() merges those
  distinct() |>
  # Then this filters to only duplicates
  group_by(envelope_ID) %>%
  filter(n() > 1)

## Young/old ----
# Vaccinium myrtillus can by definition only have new leaves as it is deciduous
error.oldVM <- DURIN_data |>
  # Filter to young-only plants
  filter(species %in% c("Vaccinium myrtillus")) |>
  # Filter to mislabelled leaf ages
  filter(leaf_age == "old")

## DURIN plot info ----
### Does the envelope site match the plot site? ----
error.durin.site <- DURIN_data |>
  #Filter to just DURIN
  filter(DroughtNet_plotID == "Not Applicable") |>
  # Separate out the plot ID for identifying species
  separate_wider_delim(nearest_DURIN_plotID, delim = "_", 
                       names = c("site.abbrv", "habitat.abbrv", "spp.abbrv", "rep.abbrv", remove = FALSE)) |>
  # Create abbreviated site codes
  mutate(site.code = case_when(
    siteID == "Lygra" ~ "LY",
    siteID == "Sogndal" ~ "SO",
    siteID == "Senja" ~ "SE",
    siteID == "Kautokeino" ~ "KA",
    TRUE ~ "unknown"
  )) |>
  # Filter to problem envelopes
  filter(site.code != site.abbrv) |>
  # Make it human readable
  relocate(c(site.code, site.abbrv), .after = envelope_ID)

### Does the envelope habitat match the DURIN plot habitat? ----
error.durin.habitat <- DURIN_data |>
  #Filter to just DURIN
  filter(DroughtNet_plotID == "Not Applicable") |>
  # Separate out the plot ID for identifying species
  separate_wider_delim(nearest_DURIN_plotID, delim = "_", 
                       names = c("site.abbrv", "habitat.abbrv", "spp.abbrv", "rep.abbrv", remove = FALSE)) |>
  # Create abbreviated species codes
  mutate(habitat.assigned = case_when(
    habitat == "Open" ~ "O",
    habitat == "Forested" ~ "F",
    TRUE ~ "unknown"
  )) |>
  # Filter to problem leaves
  filter(habitat.assigned != habitat.abbrv) |>
  # Make it human readable
  relocate(c(habitat.assigned, habitat.abbrv, nearest_DURIN_plotID), .after = envelope_ID)

### How many leaves are there for each plant? ----
# RECOMMENDED you run this AFTER updating all the other fields listed above
# Calculate the maximum number of leaves for each plant
durin.max.leaf_nr <- DURIN_data |>
  # Filter to just DURIN
  filter(DroughtNet_plotID == "Not Applicable") |>
  # Select the columns needed
  select(siteID, habitat, species, plant_nr, leaf_nr) |>
  # Remove duplicate data
  # distinct() |>
  # Sort by plant number and slice the maximum
  group_by(siteID,habitat, species, plant_nr) |>
  slice_max(leaf_nr) |>
  dplyr::rename(max.leaf.n = leaf_nr)


## Replicates ----
### Plant number -----
# Which envelopes are missing plant number?
error.durin.plantnr.missing <- DURIN_data |>
  # Filter out known issues (wrong species)
  # filter(!envelope_ID %in% c("AYN9607", "AST3380")) |>
  # Filter to NA values
  filter(is.na(plant_nr))

nr.missing.list <- as.list(error.durin.plantnr.missing$envelope_ID)



### Leaf number ----
check.plant <- function(plot, plantnr) {
  data = durin |>
    select(envelope_ID, siteID,
           DURIN_plot,
           plotNR, habitat,
           species, plant_nr, leaf_nr, leaf_age, plant_height,
           calluna_shoot_type) |>
    filter(DURIN_plot == plot & plant_nr == plantnr) |>
    arrange(plant_nr, calluna_shoot_type, leaf_age, leaf_nr)
  data
}

# Which envelopes are missing leaf numbers?
error.durin.leafnr.missing <- DURIN_data |>
  # Filter to NA values
  filter(is.na(leaf_nr))

# Which plants are missing leaves (or have extras)?
error.durin.leaves <- DURIN_data |>
  filter(DroughtNet_plotID == "Not Applicable") |>
  filter(proj_2024 %in% c("TT Hot", "TT Cold") |> 
  dplyr::group_by(siteID, habitat, plant_nr) %>%
  dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
  dplyr::filter(n != 14)

### Leaf age ----
# Which envelopes are missing leaf ages?
error.durin.age.missing <- durin |>
  # Filter to species with young and old leaves
  filter(species %in% c("Vaccinium vitis-idaea", "Empetrum nigrum")) |>
  # Filter to NA values
  filter(is.na(leaf_age))

age.missing.list <- as.list(error.durin.age.missing$envelope_ID)

```

## Flagging Data Value Issues

```{r}
## Do wet and dry mass hold an expected relationship? ----
library(ggh4x)

ggplot(DURIN_data,
       aes(x = wet_mass_g, y = dry_mass_g, color = leaf_age)) +
  geom_point(alpha = 0.5) +
  facet_wrap2(~species, scales = "free") +
  theme_bw()

ggsave("visualizations/2023.10.17_dry.wetMass_scaledtobulkleafnr.png")

ggplot(durin |> mutate(dry_mass_g = as.numeric(dry_mass_g))|>
         mutate(mass_ratio = dry_mass_g/wet_mass_g),
       aes(x = species, y = mass_ratio, color = leaf_age)) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(position = position_jitterdodge()) +
  geom_point(data = durin |> mutate(mass_ratio = dry_mass_g/wet_mass_g) |>
               filter(envelope_ID %in% reweigh), color = "red") +
  facet_wrap2(~species, scales = "free") +
  theme_bw()

ggsave()

# Identify the outliers
error.massratio <- DURIN_data |>
  # Make dry mass numeric
  mutate(dry_mass_g = as.numeric(dry_mass_g)) |>
  # Make ratio of dry to wet mass
  mutate(mass_ratio = dry_mass_g/wet_mass_g) |>
  # Outlier values are eyeballed from the above graph
  mutate(flag = case_when(
    species == "Calluna vulgaris" & wet_mass_g > 0.1 ~ "high wet_mass_g",
    species == "Calluna vulgaris" & dry_mass_g > 0.007 ~ "high dry_mass_g",
    species == "Empetrum nigrum" & wet_mass_g > 0.05 ~ "high wet_mass_g",
    species == "Empetrum nigrum" & dry_mass_g > 0.01 ~ "high dry_mass_g",
    species == "Vaccinium myrtillus" & wet_mass_g > 0.1 ~ "high wet_mass_g",
    species == "Vaccinium myrtillus" & dry_mass_g > 0.027 ~ "high dry_mass_g",
    species == "Vaccinium vitis-idaea" & wet_mass_g > 0.25 ~ "high wet_mass_g",
    species == "Vaccinium vitis-idaea" & dry_mass_g > 0.075 ~ "high dry_mass_g",
    species == "Calluna vulgaris" & mass_ratio > 0.75 ~ "high dry to wet mass ratio",
    species == "Empetrum nigrum" & mass_ratio > 0.75 ~ "high dry to wet mass ratio",
    species == "Vaccinium myrtillus" & mass_ratio > 0.6 ~ "high dry to wet mass ratio",
    species == "Vaccinium myrtillus" & mass_ratio < 0.2 ~ "low dry to wet mass ratio",
    species == "Vaccinium vitis-idaea" & mass_ratio > 0.75 ~ "high dry to wet mass ratio",
    species == "Vaccinium vitis-idaea" & mass_ratio < 0.2 ~ "low dry to wet mass ratio",
    dry_mass_g > wet_mass_g ~ "dry mass more than wet mass",
    TRUE ~ "ok"
  )) |>
  # Filter to the problem columns
  filter(flag != "ok")|>
  # Prep for the envelope check sheet
  mutate(`Supporting Text Comment` = paste0("Check envelope", ". ", flag)) |>
  select(envelope_ID, `Supporting Text Comment`, mass_ratio) |>
  arrange(`Supporting Text Comment`)

# For some reason the flag for dry mass greater than wet doesn't work
table(error.massratio$flag)

write.csv(error.massratio, "output/2024.05.15_error.massratio.csv")

## Do SLA and leaf area hold an expected relationship? ----
### Visualize outliers

ggplot(DURIN_data,
       aes(x = leaf_area, y = SLA, color = leaf_age)) +
  geom_point(alpha = 0.3) +
  facet_wrap(~species, scales = "free", ncol = 4) +
  theme_bw()

ggsave("visualizations/2024.07.15_SLAxAreaErrors_scaledtobulkleafnr.png")

# From these visuals, we can estimate reasonable values
error.SLAxArea <- error.sla |>
  # Flag possible errors
  mutate(flag_SLA = case_when(
    species == "Calluna vulgaris" & (SLA < 25 | SLA > 150) ~ "CV SLA error",
    species == "Empetrum nigrum" & (SLA < 40 | SLA > 200) ~ "EN SLA error",
    species == "Vaccinium myrtillus" & (SLA < 125 | SLA > 400) ~ "VM SLA error",
    species == "Vaccinium vitis-idaea" & (SLA < 40 | SLA > 300) ~ "VV SLA error",
    TRUE ~ "okay"
  ),
  flag_area = case_when(
    species == "Calluna vulgaris" & (leaf_area_scaled < 0 | leaf_area_scaled > 0.3) ~ "CV area error",
    species == "Empetrum nigrum" & (leaf_area_scaled < 0 | leaf_area_scaled > 0.2) ~ "EN area error",
    species == "Vaccinium myrtillus" & (leaf_area_scaled < 0 | leaf_area_scaled > 3.5) ~ "VM area error",
    species == "Vaccinium vitis-idaea" & (leaf_area_scaled < 0 | leaf_area_scaled > 3.5) ~ "VV area error",
    TRUE ~ "okay"
  )) |>
  filter(flag_SLA != "okay" | flag_area != "okay") |>
  select(envelope_ID, flag_SLA, flag_area, wet_mass_g, dry_mass_g, leaf_area, SLA) |>
  distinct()

write.csv(error.SLAxArea, "output/2024.107.115_SLAxAreaErrors.csv")

```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

## Exploratory Thermal Curves

```{r warning=FALSE}
# Hot Tolerance
DURIN_TT <- subset(DURIN_data, envelope_ID != "")

# Plot Initial Curves
DURIN_TT %>% 
  # Filters out issues with hot plants with temps below lowest bath of 20
  filter(TempExp >= 20) %>% 
  filter(proj_2024 != "Multiple") %>% 
  filter(proj_2024 == "TT Hot") %>% 
  filter(DroughtNet_plotID == "Not Applicable") %>% 
  ggplot(aes(x = TempExp, y= as.numeric(as.character(FvFm_Final)),
             group = PlantSampleID, color = habitat)) +
  geom_point()+ 
  geom_smooth(method = "loess",
              se = FALSE, aes(group = PlantSampleID, color = habitat)) +
  facet_grid(species ~ siteID)

# Cold Tolerance

# Plot Initial Curves
DURIN_TT %>% 
  # Filters out issues with hot plants with temps below lowest bath of 20
  filter(TempExp <= 5) %>% 
  filter(proj_2024 != "Multiple") %>% 
  filter(proj_2024 == "TT Cold") %>% 
  filter(DroughtNet_plotID == "Not Applicable") %>% 
  ggplot(aes(x = TempExp, y= as.numeric(as.character(FvFm_Final)),
             group = PlantSampleID, color = habitat)) +
  geom_point()+ 
  geom_smooth(method = "loess",
              se = FALSE, aes(group = PlantSampleID, linetype = habitat)) +
    geom_smooth(method = "loess",
              se = FALSE, aes(group = habitat, color = habitat)) +
  facet_grid(species ~ siteID)

```

```{r}
#Thanks for checking out this code for estimating heat tolerances using variable fluorescence!
#Be sure to the read the Read.me.txt file.
#Below, the "psiiht" function can calculate heat tolerances of PSII heat tolerance. 
#For this function, define the the columns with the 1) Temperature & 2) FvFm variables, then the 3) control temperature, the 4) id/unique factor that you 
#want to estimate the heat tolerances for, 5) indicate if you want to make plots, 6) the number of bootsrap iterations for estimating heat tolerances

# setwd("C:/Users/sge010/OneDrive - University of Bergen/Documents/DURIN/Durin_data_project/Heat_tolerance_function/")
library(car)
htdata = read.csv("Sample_FvFm_data.csv")
psiiht=function( Temperature, FvFm, control.temp, id, plot.est, boots){
  l1=list(control.temp = control.temp, plot.est = plot.est, boots = boots)
  attach(l1)
  HTdf = data.frame(Temperature = Temperature, FvFm = FvFm, id = id)
  
 return(do.call("rbind", by(HTdf, list(HTdf$id), function(df){
   Temperature=df[,which(colnames(df)=="Temperature")]
   FvFm=df[,which(colnames(df)=="FvFm")]
   id=df[,which(colnames(df)=="id")]
   #get parameter estimates for logistic decay model
   cof=coef(lm(logit(FvFm)~Temperature)) 
   #Fit a non linear least squares model to the FvFm and Temperature data
   HT.model <- nls(FvFm ~ theta1/(1 + exp(-(theta2 + theta3*Temperature))),  start=list(theta1 = .8, theta2 = cof[1], theta3 = cof[2]),
                   trace=F, control=list(maxiter=1000, tol=1e-3))
   
   #Use the parameter estimates (coef(HT.model)[#])from the HT.model to predict a new fit based on a heat treatments from 23-62 degrees celcius. Here, # = 1:3.
   y<-coef(HT.model)[1]/(1+exp(-(coef(HT.model)[2]+coef(HT.model)[3]*seq(23,62)))) 
   
   #Calculate half of the control Fv/Fm & a 95% reduction in FvFm with reference to control
   half=mean(na.omit(FvFm[which(Temperature==control.temp)]))/2  
   nine5=mean(na.omit(FvFm[which(Temperature==control.temp)]))*0.05  
   #95 Confidence Interval
   predict.boot=matrix(NA,40, boots)
   T95=T50=Tcrit=c()
   for(k in 1:boots){
     #print(k)
     srows <- sample(1:length(Temperature), length(Temperature),TRUE)
     
     if(class(try(nls(FvFm[srows] ~ theta1/(1 + exp(-(theta2 + theta3*Temperature[srows]))),  start=list(theta1 = .8, theta2 = cof[1], theta3 = cof[2]),
                      trace=F, control=list(maxiter=1000, tol=1e-3)), silent=T)[[1]])=="nlsModel")
     {HT.model2 <- nls(FvFm[srows] ~ theta1/(1 + exp(-(theta2 + theta3*Temperature[srows]))),  start=list(theta1 = .8, theta2 = cof[1], theta3 = cof[2]),
                       trace=F, control=list(maxiter=1000, tol=1e-6))
     predict.boot[,k]=coef(HT.model2)[1]/(1+exp(-(coef(HT.model2)[2]+coef(HT.model2)[3]*seq(23,62)))) 
     #Estimate T95
     T95[k]=(-log((coef(HT.model2)[1]/nine5)-1)-coef(HT.model2)[2])/coef(HT.model2)[3] 
     
     #Estimate T50
     T50[k]=(-log((coef(HT.model2)[[1]]/half)-1)-coef(HT.model2)[[2]])/coef(HT.model2)[[3]]
     T50k=(-log((coef(HT.model2)[[1]]/half)-1)-coef(HT.model2)[[2]])/coef(HT.model2)[[3]]
     #Use model to predict changes in FvFm & make new dataframe
     predict=data.frame(x=seq(23,62),y=coef(HT.model2)[1]/(1+exp(-(coef(HT.model2)[2]+coef(HT.model2)[3]*seq(23,62)))) ) #create a dataframe of predictions
     df1=cbind(predict[-1,], predict[-nrow(predict),])[,c(3,1,4,2)]
     #Use new dataframe to estimate the slope at between each 1-degree interval
     df1$slp=as.vector(apply(df1, 1, function(x) summary(lm((x[3:4]) ~ x[1:2])) [[4]][[2]] ))
     slp.at.tcrit=round(min(df1$slp), 3)*.15 #Determine where slope is 15% of max slope & round
     #Estimate the FvFm at which the slope is 15% of max slope & less than T50
     fvfv.at.tcrit=df1[which(abs(df1[which(df1[,1]<T50k),]$slp-slp.at.tcrit)==min(abs(df1[which(df1[,1]<T50k),]$slp-slp.at.tcrit))),][1,3]
     Tcrit[k]=(-log((coef(HT.model2)[[1]]/fvfv.at.tcrit)-1)-coef(HT.model2)[[2]])/coef(HT.model2)[[3]] # Estimate the temperatureat which the slope is 15% of max slope
     
     }else{(class(try(nls(FvFm ~ theta1/(1 + exp(-(theta2 + theta3*Temperature))),  start=list(theta1 = .8, theta2 = cof[1], theta3 = cof[2]),
                          data=data2[srows,], trace=F, control=list(maxiter=1000, tol=1e-3)), silent=T)[[1]])=="list")
       predict.boot[,k]=NA
       T95[k]=NA
       T50[k]=NA
       Tcrit[k]=NA }}
   
   FvFm.boot=t(apply(predict.boot, 1, function(x){quantile(x,c(0.025,0.975),na.rm=T)}))
   
   #Tcrit.ci=quantile(Tcrit,c(0.025,0.975),na.rm=T)
   T50.ci=quantile(T50,c(0.025,0.975),na.rm=T)
   #T95.ci=quantile(T95,c(0.025,0.975),na.rm=T)
   
   if(plot.est==T){ 
     plot(NULL, NULL,xlab="Temperature",ylab="Fv/Fm",xlim=c(23,65),ylim=c(0,0.9), bty="l", lty=2)
     text(22,0.3, pos=4, paste(unique(paste(id))), font=4)
     points(Temperature, FvFm, xlab="Temperature", ylab="Fv/Fm",xlim=c(23,65), ylim=c(0,0.85), bty="l", lty=2, pch=5,  col="black")
     lines(seq(23,62), y,lwd=1, col="black")
     if(boots>1){
     lines(seq(23,62), FvFm.boot[,1],lty=3, col="black")
     lines(seq(23,62), FvFm.boot[,2],lty=3, col="black")
     }
     text(30,0, paste('Tcrit:', round(mean(na.omit(Tcrit)),1)), pos=4,col="light gray")
     abline(v=round(mean(na.omit(Tcrit)),1), lty=2,lwd=1.5, col="light gray",  cex=0.8)
     text(30,.1, paste('T50:',round(mean(na.omit(T50)),1)), pos=4, col="gray")
     abline(v=round(mean(na.omit(T50)),1), lty=2,lwd=1.5, col="gray",cex=0.8)
     text(30,.2, paste('T95:',round(mean(na.omit(T95)),1)),pos=4, col="black")
     abline(v=round(mean(na.omit(T95)),1), lty=2,lwd=1.5, col="black", cex=0.8)
   }
   return(data.frame(id=(unique(id)), 
                     #Tcrit.lci=round(Tcrit.ci[[1]],1),
                     Tcrit.mn=round(mean(na.omit(Tcrit)),1),  
                     #Tcrit.uci=round(Tcrit.ci[[2]],1),
                     
                     #T50.lci=round(T50.ci[[1]],1),
                     T50.mn=round(mean(na.omit(T50)),1),  
                     #T50.uci=round(T50.ci[[2]],1),
                     
                     #T95.lci=round(T95.ci[[1]],1),
                     T95.mn=round(mean(na.omit(T95)),1)  
                     #T95.uci=round(T95.ci[[2]],1)))
   ))
 })))
  detach(l1)
}

# Run Function
# Hot data only for now

DURIN_TT_HOT <- subset(DURIN_TT, proj_2024 != "TT Hot")
# Create concantenated ID code for the plants
DURIN_TT_HOT$PlantSampleID = paste(DURIN_TT_HOT$siteID, DURIN_TT_HOT$habitat,
                                   DURIN_TT_HOT$species, DURIN_TT_HOT$plant_nr,
                                   sep="_")

psiiht(Temperature = DURIN_TT_HOT$TempExp,
       FvFm = DURIN_TT_HOT$FvFm_Final,
       control.temp = 20,
       id = DURIN_TT_HOT$PlantSampleID,
       plot.est = T,
       boots = 5)
```
